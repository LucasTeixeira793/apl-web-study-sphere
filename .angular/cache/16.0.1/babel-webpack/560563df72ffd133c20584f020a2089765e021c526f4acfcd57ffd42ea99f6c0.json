{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {Object<string, ComponentCategory>} Components\n * @typedef {Object<string, ComponentEntry | string>} ComponentCategory\n *\n * @typedef ComponentEntry\n * @property {string} [title] The title of the component.\n * @property {string} [owner] The GitHub user name of the owner.\n * @property {boolean} [noCSS=false] Whether the component doesn't have style sheets which should also be loaded.\n * @property {string | string[]} [alias] An optional list of aliases for the id of the component.\n * @property {Object<string, string>} [aliasTitles] An optional map from an alias to its title.\n *\n * Aliases which are not in this map will the get title of the component.\n * @property {string | string[]} [optional]\n * @property {string | string[]} [require]\n * @property {string | string[]} [modify]\n */\nvar getLoader = function () {\n  /**\n   * A function which does absolutely nothing.\n   *\n   * @type {any}\n   */\n  var noop = function () {};\n\n  /**\n   * Invokes the given callback for all elements of the given value.\n   *\n   * If the given value is an array, the callback will be invokes for all elements. If the given value is `null` or\n   * `undefined`, the callback will not be invoked. In all other cases, the callback will be invoked with the given\n   * value as parameter.\n   *\n   * @param {null | undefined | T | T[]} value\n   * @param {(value: T, index: number) => void} callbackFn\n   * @returns {void}\n   * @template T\n   */\n  function forEach(value, callbackFn) {\n    if (Array.isArray(value)) {\n      value.forEach(callbackFn);\n    } else if (value != null) {\n      callbackFn(value, 0);\n    }\n  }\n\n  /**\n   * Returns a new set for the given string array.\n   *\n   * @param {string[]} array\n   * @returns {StringSet}\n   *\n   * @typedef {Object<string, true>} StringSet\n   */\n  function toSet(array) {\n    /** @type {StringSet} */\n    var set = {};\n    for (var i = 0, l = array.length; i < l; i++) {\n      set[array[i]] = true;\n    }\n    return set;\n  }\n\n  /**\n   * Creates a map of every components id to its entry.\n   *\n   * @param {Components} components\n   * @returns {EntryMap}\n   *\n   * @typedef {{ readonly [id: string]: Readonly<ComponentEntry> | undefined }} EntryMap\n   */\n  function createEntryMap(components) {\n    /** @type {Object<string, Readonly<ComponentEntry>>} */\n    var map = {};\n    for (var categoryName in components) {\n      var category = components[categoryName];\n      for (var id in category) {\n        if (id != 'meta') {\n          /** @type {ComponentEntry | string} */\n          var entry = category[id];\n          map[id] = typeof entry == 'string' ? {\n            title: entry\n          } : entry;\n        }\n      }\n    }\n    return map;\n  }\n\n  /**\n   * Creates a full dependencies map which includes all types of dependencies and their transitive dependencies.\n   *\n   * @param {EntryMap} entryMap\n   * @returns {DependencyResolver}\n   *\n   * @typedef {(id: string) => StringSet} DependencyResolver\n   */\n  function createDependencyResolver(entryMap) {\n    /** @type {Object<string, StringSet>} */\n    var map = {};\n    var _stackArray = [];\n\n    /**\n     * Adds the dependencies of the given component to the dependency map.\n     *\n     * @param {string} id\n     * @param {string[]} stack\n     */\n    function addToMap(id, stack) {\n      if (id in map) {\n        return;\n      }\n      stack.push(id);\n\n      // check for circular dependencies\n      var firstIndex = stack.indexOf(id);\n      if (firstIndex < stack.length - 1) {\n        throw new Error('Circular dependency: ' + stack.slice(firstIndex).join(' -> '));\n      }\n\n      /** @type {StringSet} */\n      var dependencies = {};\n      var entry = entryMap[id];\n      if (entry) {\n        /**\n         * This will add the direct dependency and all of its transitive dependencies to the set of\n         * dependencies of `entry`.\n         *\n         * @param {string} depId\n         * @returns {void}\n         */\n        function handleDirectDependency(depId) {\n          if (!(depId in entryMap)) {\n            throw new Error(id + ' depends on an unknown component ' + depId);\n          }\n          if (depId in dependencies) {\n            // if the given dependency is already in the set of deps, then so are its transitive deps\n            return;\n          }\n          addToMap(depId, stack);\n          dependencies[depId] = true;\n          for (var transitiveDepId in map[depId]) {\n            dependencies[transitiveDepId] = true;\n          }\n        }\n        forEach(entry.require, handleDirectDependency);\n        forEach(entry.optional, handleDirectDependency);\n        forEach(entry.modify, handleDirectDependency);\n      }\n      map[id] = dependencies;\n      stack.pop();\n    }\n    return function (id) {\n      var deps = map[id];\n      if (!deps) {\n        addToMap(id, _stackArray);\n        deps = map[id];\n      }\n      return deps;\n    };\n  }\n\n  /**\n   * Returns a function which resolves the aliases of its given id of alias.\n   *\n   * @param {EntryMap} entryMap\n   * @returns {(idOrAlias: string) => string}\n   */\n  function createAliasResolver(entryMap) {\n    /** @type {Object<string, string> | undefined} */\n    var map;\n    return function (idOrAlias) {\n      if (idOrAlias in entryMap) {\n        return idOrAlias;\n      } else {\n        // only create the alias map if necessary\n        if (!map) {\n          map = {};\n          for (var id in entryMap) {\n            var entry = entryMap[id];\n            forEach(entry && entry.alias, function (alias) {\n              if (alias in map) {\n                throw new Error(alias + ' cannot be alias for both ' + id + ' and ' + map[alias]);\n              }\n              if (alias in entryMap) {\n                throw new Error(alias + ' cannot be alias of ' + id + ' because it is a component.');\n              }\n              map[alias] = id;\n            });\n          }\n        }\n        return map[idOrAlias] || idOrAlias;\n      }\n    };\n  }\n\n  /**\n   * @typedef LoadChainer\n   * @property {(before: T, after: () => T) => T} series\n   * @property {(values: T[]) => T} parallel\n   * @template T\n   */\n\n  /**\n   * Creates an implicit DAG from the given components and dependencies and call the given `loadComponent` for each\n   * component in topological order.\n   *\n   * @param {DependencyResolver} dependencyResolver\n   * @param {StringSet} ids\n   * @param {(id: string) => T} loadComponent\n   * @param {LoadChainer<T>} [chainer]\n   * @returns {T}\n   * @template T\n   */\n  function loadComponentsInOrder(dependencyResolver, ids, loadComponent, chainer) {\n    var series = chainer ? chainer.series : undefined;\n    var parallel = chainer ? chainer.parallel : noop;\n\n    /** @type {Object<string, T>} */\n    var cache = {};\n\n    /**\n     * A set of ids of nodes which are not depended upon by any other node in the graph.\n     *\n     * @type {StringSet}\n     */\n    var ends = {};\n\n    /**\n     * Loads the given component and its dependencies or returns the cached value.\n     *\n     * @param {string} id\n     * @returns {T}\n     */\n    function handleId(id) {\n      if (id in cache) {\n        return cache[id];\n      }\n\n      // assume that it's an end\n      // if it isn't, it will be removed later\n      ends[id] = true;\n\n      // all dependencies of the component in the given ids\n      var dependsOn = [];\n      for (var depId in dependencyResolver(id)) {\n        if (depId in ids) {\n          dependsOn.push(depId);\n        }\n      }\n\n      /**\n       * The value to be returned.\n       *\n       * @type {T}\n       */\n      var value;\n      if (dependsOn.length === 0) {\n        value = loadComponent(id);\n      } else {\n        var depsValue = parallel(dependsOn.map(function (depId) {\n          var value = handleId(depId);\n          // none of the dependencies can be ends\n          delete ends[depId];\n          return value;\n        }));\n        if (series) {\n          // the chainer will be responsibly for calling the function calling loadComponent\n          value = series(depsValue, function () {\n            return loadComponent(id);\n          });\n        } else {\n          // we don't have a chainer, so we call loadComponent ourselves\n          loadComponent(id);\n        }\n      }\n\n      // cache and return\n      return cache[id] = value;\n    }\n    for (var id in ids) {\n      handleId(id);\n    }\n\n    /** @type {T[]} */\n    var endValues = [];\n    for (var endId in ends) {\n      endValues.push(cache[endId]);\n    }\n    return parallel(endValues);\n  }\n\n  /**\n   * Returns whether the given object has any keys.\n   *\n   * @param {object} obj\n   */\n  function hasKeys(obj) {\n    for (var key in obj) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns an object which provides methods to get the ids of the components which have to be loaded (`getIds`) and\n   * a way to efficiently load them in synchronously and asynchronous contexts (`load`).\n   *\n   * The set of ids to be loaded is a superset of `load`. If some of these ids are in `loaded`, the corresponding\n   * components will have to reloaded.\n   *\n   * The ids in `load` and `loaded` may be in any order and can contain duplicates.\n   *\n   * @param {Components} components\n   * @param {string[]} load\n   * @param {string[]} [loaded=[]] A list of already loaded components.\n   *\n   * If a component is in this list, then all of its requirements will also be assumed to be in the list.\n   * @returns {Loader}\n   *\n   * @typedef Loader\n   * @property {() => string[]} getIds A function to get all ids of the components to load.\n   *\n   * The returned ids will be duplicate-free, alias-free and in load order.\n   * @property {LoadFunction} load A functional interface to load components.\n   *\n   * @typedef {<T> (loadComponent: (id: string) => T, chainer?: LoadChainer<T>) => T} LoadFunction\n   * A functional interface to load components.\n   *\n   * The `loadComponent` function will be called for every component in the order in which they have to be loaded.\n   *\n   * The `chainer` is useful for asynchronous loading and its `series` and `parallel` functions can be thought of as\n   * `Promise#then` and `Promise.all`.\n   *\n   * @example\n   * load(id => { loadComponent(id); }); // returns undefined\n   *\n   * await load(\n   *     id => loadComponentAsync(id), // returns a Promise for each id\n   *     {\n   *         series: async (before, after) => {\n   *             await before;\n   *             await after();\n   *         },\n   *         parallel: async (values) => {\n   *             await Promise.all(values);\n   *         }\n   *     }\n   * );\n   */\n  function getLoader(components, load, loaded) {\n    var entryMap = createEntryMap(components);\n    var resolveAlias = createAliasResolver(entryMap);\n    load = load.map(resolveAlias);\n    loaded = (loaded || []).map(resolveAlias);\n    var loadSet = toSet(load);\n    var loadedSet = toSet(loaded);\n\n    // add requirements\n\n    load.forEach(addRequirements);\n    function addRequirements(id) {\n      var entry = entryMap[id];\n      forEach(entry && entry.require, function (reqId) {\n        if (!(reqId in loadedSet)) {\n          loadSet[reqId] = true;\n          addRequirements(reqId);\n        }\n      });\n    }\n\n    // add components to reload\n\n    // A component x in `loaded` has to be reloaded if\n    //  1) a component in `load` modifies x.\n    //  2) x depends on a component in `load`.\n    // The above two condition have to be applied until nothing changes anymore.\n\n    var dependencyResolver = createDependencyResolver(entryMap);\n\n    /** @type {StringSet} */\n    var loadAdditions = loadSet;\n    /** @type {StringSet} */\n    var newIds;\n    while (hasKeys(loadAdditions)) {\n      newIds = {};\n\n      // condition 1)\n      for (var loadId in loadAdditions) {\n        var entry = entryMap[loadId];\n        forEach(entry && entry.modify, function (modId) {\n          if (modId in loadedSet) {\n            newIds[modId] = true;\n          }\n        });\n      }\n\n      // condition 2)\n      for (var loadedId in loadedSet) {\n        if (!(loadedId in loadSet)) {\n          for (var depId in dependencyResolver(loadedId)) {\n            if (depId in loadSet) {\n              newIds[loadedId] = true;\n              break;\n            }\n          }\n        }\n      }\n      loadAdditions = newIds;\n      for (var newId in loadAdditions) {\n        loadSet[newId] = true;\n      }\n    }\n\n    /** @type {Loader} */\n    var loader = {\n      getIds: function () {\n        var ids = [];\n        loader.load(function (id) {\n          ids.push(id);\n        });\n        return ids;\n      },\n      load: function (loadComponent, chainer) {\n        return loadComponentsInOrder(dependencyResolver, loadSet, loadComponent, chainer);\n      }\n    };\n    return loader;\n  }\n  return getLoader;\n}();\nif (typeof module !== 'undefined') {\n  module.exports = getLoader;\n}","map":{"version":3,"names":["getLoader","noop","forEach","value","callbackFn","Array","isArray","toSet","array","set","i","l","length","createEntryMap","components","map","categoryName","category","id","entry","title","createDependencyResolver","entryMap","_stackArray","addToMap","stack","push","firstIndex","indexOf","Error","slice","join","dependencies","handleDirectDependency","depId","transitiveDepId","require","optional","modify","pop","deps","createAliasResolver","idOrAlias","alias","loadComponentsInOrder","dependencyResolver","ids","loadComponent","chainer","series","undefined","parallel","cache","ends","handleId","dependsOn","depsValue","endValues","endId","hasKeys","obj","key","load","loaded","resolveAlias","loadSet","loadedSet","addRequirements","reqId","loadAdditions","newIds","loadId","modId","loadedId","newId","loader","getIds","module","exports"],"sources":["C:/Projetos/apl-web-study-sphere/node_modules/prismjs/dependencies.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {Object<string, ComponentCategory>} Components\n * @typedef {Object<string, ComponentEntry | string>} ComponentCategory\n *\n * @typedef ComponentEntry\n * @property {string} [title] The title of the component.\n * @property {string} [owner] The GitHub user name of the owner.\n * @property {boolean} [noCSS=false] Whether the component doesn't have style sheets which should also be loaded.\n * @property {string | string[]} [alias] An optional list of aliases for the id of the component.\n * @property {Object<string, string>} [aliasTitles] An optional map from an alias to its title.\n *\n * Aliases which are not in this map will the get title of the component.\n * @property {string | string[]} [optional]\n * @property {string | string[]} [require]\n * @property {string | string[]} [modify]\n */\n\nvar getLoader = (function () {\n\n\t/**\n\t * A function which does absolutely nothing.\n\t *\n\t * @type {any}\n\t */\n\tvar noop = function () { };\n\n\t/**\n\t * Invokes the given callback for all elements of the given value.\n\t *\n\t * If the given value is an array, the callback will be invokes for all elements. If the given value is `null` or\n\t * `undefined`, the callback will not be invoked. In all other cases, the callback will be invoked with the given\n\t * value as parameter.\n\t *\n\t * @param {null | undefined | T | T[]} value\n\t * @param {(value: T, index: number) => void} callbackFn\n\t * @returns {void}\n\t * @template T\n\t */\n\tfunction forEach(value, callbackFn) {\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(callbackFn);\n\t\t} else if (value != null) {\n\t\t\tcallbackFn(value, 0);\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new set for the given string array.\n\t *\n\t * @param {string[]} array\n\t * @returns {StringSet}\n\t *\n\t * @typedef {Object<string, true>} StringSet\n\t */\n\tfunction toSet(array) {\n\t\t/** @type {StringSet} */\n\t\tvar set = {};\n\t\tfor (var i = 0, l = array.length; i < l; i++) {\n\t\t\tset[array[i]] = true;\n\t\t}\n\t\treturn set;\n\t}\n\n\t/**\n\t * Creates a map of every components id to its entry.\n\t *\n\t * @param {Components} components\n\t * @returns {EntryMap}\n\t *\n\t * @typedef {{ readonly [id: string]: Readonly<ComponentEntry> | undefined }} EntryMap\n\t */\n\tfunction createEntryMap(components) {\n\t\t/** @type {Object<string, Readonly<ComponentEntry>>} */\n\t\tvar map = {};\n\n\t\tfor (var categoryName in components) {\n\t\t\tvar category = components[categoryName];\n\t\t\tfor (var id in category) {\n\t\t\t\tif (id != 'meta') {\n\t\t\t\t\t/** @type {ComponentEntry | string} */\n\t\t\t\t\tvar entry = category[id];\n\t\t\t\t\tmap[id] = typeof entry == 'string' ? { title: entry } : entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n\t/**\n\t * Creates a full dependencies map which includes all types of dependencies and their transitive dependencies.\n\t *\n\t * @param {EntryMap} entryMap\n\t * @returns {DependencyResolver}\n\t *\n\t * @typedef {(id: string) => StringSet} DependencyResolver\n\t */\n\tfunction createDependencyResolver(entryMap) {\n\t\t/** @type {Object<string, StringSet>} */\n\t\tvar map = {};\n\t\tvar _stackArray = [];\n\n\t\t/**\n\t\t * Adds the dependencies of the given component to the dependency map.\n\t\t *\n\t\t * @param {string} id\n\t\t * @param {string[]} stack\n\t\t */\n\t\tfunction addToMap(id, stack) {\n\t\t\tif (id in map) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstack.push(id);\n\n\t\t\t// check for circular dependencies\n\t\t\tvar firstIndex = stack.indexOf(id);\n\t\t\tif (firstIndex < stack.length - 1) {\n\t\t\t\tthrow new Error('Circular dependency: ' + stack.slice(firstIndex).join(' -> '));\n\t\t\t}\n\n\t\t\t/** @type {StringSet} */\n\t\t\tvar dependencies = {};\n\n\t\t\tvar entry = entryMap[id];\n\t\t\tif (entry) {\n\t\t\t\t/**\n\t\t\t\t * This will add the direct dependency and all of its transitive dependencies to the set of\n\t\t\t\t * dependencies of `entry`.\n\t\t\t\t *\n\t\t\t\t * @param {string} depId\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tfunction handleDirectDependency(depId) {\n\t\t\t\t\tif (!(depId in entryMap)) {\n\t\t\t\t\t\tthrow new Error(id + ' depends on an unknown component ' + depId);\n\t\t\t\t\t}\n\t\t\t\t\tif (depId in dependencies) {\n\t\t\t\t\t\t// if the given dependency is already in the set of deps, then so are its transitive deps\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\taddToMap(depId, stack);\n\t\t\t\t\tdependencies[depId] = true;\n\t\t\t\t\tfor (var transitiveDepId in map[depId]) {\n\t\t\t\t\t\tdependencies[transitiveDepId] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tforEach(entry.require, handleDirectDependency);\n\t\t\t\tforEach(entry.optional, handleDirectDependency);\n\t\t\t\tforEach(entry.modify, handleDirectDependency);\n\t\t\t}\n\n\t\t\tmap[id] = dependencies;\n\n\t\t\tstack.pop();\n\t\t}\n\n\t\treturn function (id) {\n\t\t\tvar deps = map[id];\n\t\t\tif (!deps) {\n\t\t\t\taddToMap(id, _stackArray);\n\t\t\t\tdeps = map[id];\n\t\t\t}\n\t\t\treturn deps;\n\t\t};\n\t}\n\n\t/**\n\t * Returns a function which resolves the aliases of its given id of alias.\n\t *\n\t * @param {EntryMap} entryMap\n\t * @returns {(idOrAlias: string) => string}\n\t */\n\tfunction createAliasResolver(entryMap) {\n\t\t/** @type {Object<string, string> | undefined} */\n\t\tvar map;\n\n\t\treturn function (idOrAlias) {\n\t\t\tif (idOrAlias in entryMap) {\n\t\t\t\treturn idOrAlias;\n\t\t\t} else {\n\t\t\t\t// only create the alias map if necessary\n\t\t\t\tif (!map) {\n\t\t\t\t\tmap = {};\n\n\t\t\t\t\tfor (var id in entryMap) {\n\t\t\t\t\t\tvar entry = entryMap[id];\n\t\t\t\t\t\tforEach(entry && entry.alias, function (alias) {\n\t\t\t\t\t\t\tif (alias in map) {\n\t\t\t\t\t\t\t\tthrow new Error(alias + ' cannot be alias for both ' + id + ' and ' + map[alias]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (alias in entryMap) {\n\t\t\t\t\t\t\t\tthrow new Error(alias + ' cannot be alias of ' + id + ' because it is a component.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmap[alias] = id;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn map[idOrAlias] || idOrAlias;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * @typedef LoadChainer\n\t * @property {(before: T, after: () => T) => T} series\n\t * @property {(values: T[]) => T} parallel\n\t * @template T\n\t */\n\n\t/**\n\t * Creates an implicit DAG from the given components and dependencies and call the given `loadComponent` for each\n\t * component in topological order.\n\t *\n\t * @param {DependencyResolver} dependencyResolver\n\t * @param {StringSet} ids\n\t * @param {(id: string) => T} loadComponent\n\t * @param {LoadChainer<T>} [chainer]\n\t * @returns {T}\n\t * @template T\n\t */\n\tfunction loadComponentsInOrder(dependencyResolver, ids, loadComponent, chainer) {\n\t\tvar series = chainer ? chainer.series : undefined;\n\t\tvar parallel = chainer ? chainer.parallel : noop;\n\n\t\t/** @type {Object<string, T>} */\n\t\tvar cache = {};\n\n\t\t/**\n\t\t * A set of ids of nodes which are not depended upon by any other node in the graph.\n\t\t *\n\t\t * @type {StringSet}\n\t\t */\n\t\tvar ends = {};\n\n\t\t/**\n\t\t * Loads the given component and its dependencies or returns the cached value.\n\t\t *\n\t\t * @param {string} id\n\t\t * @returns {T}\n\t\t */\n\t\tfunction handleId(id) {\n\t\t\tif (id in cache) {\n\t\t\t\treturn cache[id];\n\t\t\t}\n\n\t\t\t// assume that it's an end\n\t\t\t// if it isn't, it will be removed later\n\t\t\tends[id] = true;\n\n\t\t\t// all dependencies of the component in the given ids\n\t\t\tvar dependsOn = [];\n\t\t\tfor (var depId in dependencyResolver(id)) {\n\t\t\t\tif (depId in ids) {\n\t\t\t\t\tdependsOn.push(depId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * The value to be returned.\n\t\t\t *\n\t\t\t * @type {T}\n\t\t\t */\n\t\t\tvar value;\n\n\t\t\tif (dependsOn.length === 0) {\n\t\t\t\tvalue = loadComponent(id);\n\t\t\t} else {\n\t\t\t\tvar depsValue = parallel(dependsOn.map(function (depId) {\n\t\t\t\t\tvar value = handleId(depId);\n\t\t\t\t\t// none of the dependencies can be ends\n\t\t\t\t\tdelete ends[depId];\n\t\t\t\t\treturn value;\n\t\t\t\t}));\n\t\t\t\tif (series) {\n\t\t\t\t\t// the chainer will be responsibly for calling the function calling loadComponent\n\t\t\t\t\tvalue = series(depsValue, function () { return loadComponent(id); });\n\t\t\t\t} else {\n\t\t\t\t\t// we don't have a chainer, so we call loadComponent ourselves\n\t\t\t\t\tloadComponent(id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// cache and return\n\t\t\treturn cache[id] = value;\n\t\t}\n\n\t\tfor (var id in ids) {\n\t\t\thandleId(id);\n\t\t}\n\n\t\t/** @type {T[]} */\n\t\tvar endValues = [];\n\t\tfor (var endId in ends) {\n\t\t\tendValues.push(cache[endId]);\n\t\t}\n\t\treturn parallel(endValues);\n\t}\n\n\t/**\n\t * Returns whether the given object has any keys.\n\t *\n\t * @param {object} obj\n\t */\n\tfunction hasKeys(obj) {\n\t\tfor (var key in obj) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns an object which provides methods to get the ids of the components which have to be loaded (`getIds`) and\n\t * a way to efficiently load them in synchronously and asynchronous contexts (`load`).\n\t *\n\t * The set of ids to be loaded is a superset of `load`. If some of these ids are in `loaded`, the corresponding\n\t * components will have to reloaded.\n\t *\n\t * The ids in `load` and `loaded` may be in any order and can contain duplicates.\n\t *\n\t * @param {Components} components\n\t * @param {string[]} load\n\t * @param {string[]} [loaded=[]] A list of already loaded components.\n\t *\n\t * If a component is in this list, then all of its requirements will also be assumed to be in the list.\n\t * @returns {Loader}\n\t *\n\t * @typedef Loader\n\t * @property {() => string[]} getIds A function to get all ids of the components to load.\n\t *\n\t * The returned ids will be duplicate-free, alias-free and in load order.\n\t * @property {LoadFunction} load A functional interface to load components.\n\t *\n\t * @typedef {<T> (loadComponent: (id: string) => T, chainer?: LoadChainer<T>) => T} LoadFunction\n\t * A functional interface to load components.\n\t *\n\t * The `loadComponent` function will be called for every component in the order in which they have to be loaded.\n\t *\n\t * The `chainer` is useful for asynchronous loading and its `series` and `parallel` functions can be thought of as\n\t * `Promise#then` and `Promise.all`.\n\t *\n\t * @example\n\t * load(id => { loadComponent(id); }); // returns undefined\n\t *\n\t * await load(\n\t *     id => loadComponentAsync(id), // returns a Promise for each id\n\t *     {\n\t *         series: async (before, after) => {\n\t *             await before;\n\t *             await after();\n\t *         },\n\t *         parallel: async (values) => {\n\t *             await Promise.all(values);\n\t *         }\n\t *     }\n\t * );\n\t */\n\tfunction getLoader(components, load, loaded) {\n\t\tvar entryMap = createEntryMap(components);\n\t\tvar resolveAlias = createAliasResolver(entryMap);\n\n\t\tload = load.map(resolveAlias);\n\t\tloaded = (loaded || []).map(resolveAlias);\n\n\t\tvar loadSet = toSet(load);\n\t\tvar loadedSet = toSet(loaded);\n\n\t\t// add requirements\n\n\t\tload.forEach(addRequirements);\n\t\tfunction addRequirements(id) {\n\t\t\tvar entry = entryMap[id];\n\t\t\tforEach(entry && entry.require, function (reqId) {\n\t\t\t\tif (!(reqId in loadedSet)) {\n\t\t\t\t\tloadSet[reqId] = true;\n\t\t\t\t\taddRequirements(reqId);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// add components to reload\n\n\t\t// A component x in `loaded` has to be reloaded if\n\t\t//  1) a component in `load` modifies x.\n\t\t//  2) x depends on a component in `load`.\n\t\t// The above two condition have to be applied until nothing changes anymore.\n\n\t\tvar dependencyResolver = createDependencyResolver(entryMap);\n\n\t\t/** @type {StringSet} */\n\t\tvar loadAdditions = loadSet;\n\t\t/** @type {StringSet} */\n\t\tvar newIds;\n\t\twhile (hasKeys(loadAdditions)) {\n\t\t\tnewIds = {};\n\n\t\t\t// condition 1)\n\t\t\tfor (var loadId in loadAdditions) {\n\t\t\t\tvar entry = entryMap[loadId];\n\t\t\t\tforEach(entry && entry.modify, function (modId) {\n\t\t\t\t\tif (modId in loadedSet) {\n\t\t\t\t\t\tnewIds[modId] = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// condition 2)\n\t\t\tfor (var loadedId in loadedSet) {\n\t\t\t\tif (!(loadedId in loadSet)) {\n\t\t\t\t\tfor (var depId in dependencyResolver(loadedId)) {\n\t\t\t\t\t\tif (depId in loadSet) {\n\t\t\t\t\t\t\tnewIds[loadedId] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tloadAdditions = newIds;\n\t\t\tfor (var newId in loadAdditions) {\n\t\t\t\tloadSet[newId] = true;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Loader} */\n\t\tvar loader = {\n\t\t\tgetIds: function () {\n\t\t\t\tvar ids = [];\n\t\t\t\tloader.load(function (id) {\n\t\t\t\t\tids.push(id);\n\t\t\t\t});\n\t\t\t\treturn ids;\n\t\t\t},\n\t\t\tload: function (loadComponent, chainer) {\n\t\t\t\treturn loadComponentsInOrder(dependencyResolver, loadSet, loadComponent, chainer);\n\t\t\t}\n\t\t};\n\n\t\treturn loader;\n\t}\n\n\treturn getLoader;\n\n}());\n\nif (typeof module !== 'undefined') {\n\tmodule.exports = getLoader;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}